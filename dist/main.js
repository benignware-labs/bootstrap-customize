/*! For license information please see main.js.LICENSE.txt */
(()=>{var __webpack_modules__={"./index.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval('__webpack_require__(/*! cssf/addons/legacy-color-vars/legacy-color-vars-runtime.js */ "./node_modules/cssf/addons/legacy-color-vars/legacy-color-vars-runtime.js");\n\n//# sourceURL=webpack://bootstrap-customize/./index.js?')},"./index.scss":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n\n\n//# sourceURL=webpack://bootstrap-customize/./index.scss?")},"./node_modules/cssf/addons/legacy-color-vars/legacy-color-vars-runtime.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval("__webpack_require__.r(__webpack_exports__);\n(function () {\n\n  function memoize(fn) {\n    const cache = new Map();\n  \n    return function(...args) {\n      const key = JSON.stringify(args);\n  \n      if (cache.has(key)) {\n        return cache.get(key);\n      }\n  \n      const result = fn.apply(this, args);\n      cache.set(key, result);\n      return result;\n    };\n  }\n\n  // Check if the value is a recognized color format\n  const isRecognizedColor = memoize((value) => {\n    const result = /^(#[0-9a-fA-F]{3,8}|rgba?\\(\\s*\\d+\\s*,\\s*\\d+\\s*,\\s*\\d+(\\s*,\\s*\\d+(\\.\\d+)?)?\\)|hsla?\\(\\s*\\d+\\s*,\\s*\\d+%,\\s*\\d+%(\\s*,\\s*\\d+(\\.\\d+)?)?\\)|\\b(?:aqua|black|blue|fuchsia|gray|green|lime|maroon|navy|olive|purple|red|silver|teal|white|yellow)\\b)$/.test(value) && !value.includes('var(');\n    // console.log('IS RECOGNIZED COLOR', value, '---\x3e', result);\n    return result;\n  });\n\n  // Extract color channels from a color string\n  const extractColorChannels = memoize((color) => {\n    let match;\n\n    // Handle hex colors (#RGB, #RRGGBB, #RRGGBBAA)\n    if ((match = color.match(/^#([a-fA-F0-9]{3,8})$/))) {\n        let hex = match[1];\n        if (hex.length === 3) hex = [...hex].map(x => x + x).join(''); // Expand #RGB to #RRGGBB\n        if (hex.length === 4) hex = [...hex].map(x => x + x).join(''); // Expand #RRGBA to #RRGGBBAA\n        const rgb = hex.match(/.{2}/g).map(x => parseInt(x, 16)); // Convert hex pairs to integers\n        return {\n            r: rgb[0],\n            g: rgb[1],\n            b: rgb[2],\n            a: rgb[3] !== undefined ? (rgb[3] / 255).toFixed(3) : 1\n        };\n    }\n\n    // Handle RGB(A) and HSL(A) colors\n    if ((match = color.match(/^(rgb|hsl)a?\\(([^)]+)\\)$/i))) {\n        const parts = match[2].split(/,\\s*/).map(x => parseFloat(x));\n        return {\n            r: parts[0],\n            g: parts[1],\n            b: parts[2],\n            a: parts[3] !== undefined ? parts[3] : 1\n        };\n    }\n\n    // Not a recognized color format\n    return null;\n  });\n\n\n  const stylesheetArray = []; // Array to hold stylesheet representations\n  let combinedStyles = {}; // Object to hold merged styles\n  const customStylesheetId = 'custom-styles'; // Identifier for the custom stylesheet\n  let customStyleSheet = null;\n\n  // Create a new <style> element and return its stylesheet\n  function createCustomStyleSheet() {\n    if (!customStyleSheet) {\n      const style = document.createElement('style');\n      style.id = customStylesheetId; // Set the title for the custom stylesheet\n      document.body.appendChild(style);\n      return style.sheet;\n    } else {\n      const style = document.querySelector(`style[id=\"${customStylesheetId}\"]`);\n      const lastElement = document.body.lastElementChild;\n\n      // Make sure the custom stylesheet is the last element in the body\n      if (customStyleSheet.ownerNode !== lastElement) {\n        document.body.appendChild(style);\n      }\n\n      // Clear the existing rules\n      while (customStyleSheet.cssRules.length) {\n        customStyleSheet.deleteRule(0);\n      }\n\n      return style.sheet;\n    }\n  }\n\n  // Function to collect all stylesheets and create a representation\n  function collectStyles() {\n      Array.from(document.styleSheets).forEach(sheet => {\n          try {\n              // Check if the stylesheet is not the custom one\n              if (sheet.title !== customStylesheetId && sheet.cssRules) {\n                  const stylesheetData = {\n                      stylesheet: sheet, // Reference to the original stylesheet\n                      data: {}, // This will hold the parsed CSS data\n                  };\n                  processStyleSheet(sheet, stylesheetData);\n                  stylesheetArray.push(stylesheetData);\n              }\n          } catch (e) {\n              console.warn(\"Cannot access stylesheet:\", e);\n          }\n      });\n  }\n\n  // Process a single stylesheet to collect its rules\n  function processStyleSheet(sheet, stylesheetData) {\n      if (!sheet.cssRules) {\n          // console.warn(\"No CSS rules found in stylesheet:\", sheet);\n          return;\n      }\n\n      Array.from(sheet.cssRules).forEach(rule => {\n          if (rule.style) {\n              processStyleRule(rule, stylesheetData.data);\n          }\n      });\n  }\n\n  // Process a style rule and store it in the stylesheet data\n  function processStyleRule(rule, data) {\n      const style = rule.style;\n      const selectorText = rule.selectorText;\n\n      // Initialize the selector in the data if it doesn't exist\n      if (!data[selectorText]) {\n          data[selectorText] = {};\n      }\n\n      // Collect all properties and their values\n      for (let i = 0; i < style.length; i++) {\n          const property = style[i];\n\n          if (!property.startsWith('--')) {\n            continue;\n          }\n          const value = style.getPropertyValue(property).trim();\n          data[selectorText][property] = value; // Store all properties\n      }\n  }\n\n  // Function to merge all stylesheet data into a combined object\n  function mergeStyles() {\n      combinedStyles = {}; // Reset combined styles\n\n      stylesheetArray.forEach(stylesheetData => {\n          const data = stylesheetData.data;\n\n          for (const selector in data) {\n              if (!combinedStyles[selector]) {\n                  combinedStyles[selector] = {};\n              }\n              for (const property in data[selector]) {\n                  // Merge properties, prioritizing the last stylesheet's value\n                  combinedStyles[selector][property] = data[selector][property];\n              }\n          }\n      });\n  }\n\n  // Function to generate a new stylesheet from the combined styles\n  function generateStylesheet() {\n    customStyleSheet = createCustomStyleSheet();\n    const rules = [];\n      \n      for (const selector in combinedStyles) {\n          const properties = combinedStyles[selector];\n          const processed = Object.entries(properties)\n                .reduce((acc, [prop, val]) => {\n                  // Check if the value is a recognized color and process it\n                  if (isRecognizedColor(val)) {\n                    \n                    const channels = extractColorChannels(val);\n                    \n                    if (channels) {\n                      acc[`${prop}-r`] = channels.r;\n                      acc[`${prop}-g`] = channels.g;\n                      acc[`${prop}-b`] = channels.b;\n                      acc[`${prop}-a`] = channels.a;\n                    }\n                  }\n                  \n                  return acc;\n                }, {});\n\n          if (Object.keys(processed).length) {\n            const ruleText = `${selector} {\\n${Object.entries(processed).map(([prop, val]) => `\\t${prop}: ${val};`).join('\\n ')}\\n}`;\n\n            rules.push(ruleText);\n          }\n      }\n\n      for (const rule of rules) {\n          customStyleSheet.insertRule(rule, customStyleSheet.cssRules.length);\n      }\n\n      // customStyleSheet.insertRule(rules.join('\\n'), customStyleSheet.cssRules.length);\n\n      // const style = document.querySelector(`style[id=\"${customStylesheetId}\"]`);\n\n      // style.textContent = rules.join('\\n');\n  }\n\n  // Patch the textContent property of the <style> element\n  function patchStyleElement() {\n      const originalTextContentSetter = HTMLStyleElement.prototype.__lookupSetter__('textContent');\n\n      Object.defineProperty(HTMLStyleElement.prototype, 'textContent', {\n          set: function(value) {\n              // Call the original setter\n              originalTextContentSetter.call(this, value);\n\n              const sheet = this.sheet;\n\n              if (sheet === customStyleSheet) {\n                  // If the stylesheet is the custom one, do nothing\n                  // console.log('Ignoring custom stylesheet');\n                  return;\n              }\n\n              // Check if the stylesheet already exists in the array\n              const stylesheetData = stylesheetArray.find(sheetData => sheetData.stylesheet === sheet);\n              if (stylesheetData) {\n                  // If it exists, process it\n                  stylesheetData.data = {}; // Clear previous data\n                  processStyleSheet(sheet, stylesheetData); // Process the stylesheet\n              } else {\n                  // If it doesn't exist, determine its position in the DOM\n                  const position = Array.from(document.styleSheets).indexOf(this);\n\n                  // Create a new stylesheet representation\n                  const newStylesheetData = {\n                      stylesheet: this.sheet,\n                      data: {}\n                  };\n                  processStyleSheet(this.sheet, newStylesheetData);\n                  // Insert it in the correct position in the array\n                  stylesheetArray.splice(position, 0, newStylesheetData);\n              }\n\n              mergeStyles(); // Merge the updated styles\n              window.requestAnimationFrame(generateStylesheet); // Generate the new stylesheet\n              generateStylesheet(); // Generate the new stylesheet\n\n          }\n      });\n  }\n\n  \n\n  // Initialize the process\n  function init() {\n      collectStyles(); // Collect all stylesheets\n      mergeStyles(); // Merge styles into combinedStyles\n      generateStylesheet(); // Generate the initial stylesheet\n      patchStyleElement(); // Patch the textContent property\n  }\n\n  init();\n})();\n\n\n//# sourceURL=webpack://bootstrap-customize/./node_modules/cssf/addons/legacy-color-vars/legacy-color-vars-runtime.js?")}},__webpack_module_cache__={};function __webpack_require__(e){var t=__webpack_module_cache__[e];if(void 0!==t)return t.exports;var n=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](n,n.exports,__webpack_require__),n.exports}__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},__webpack_require__("./index.scss");var __webpack_exports__=__webpack_require__("./index.js")})();